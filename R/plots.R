#' Plot Stacked Bar Plots explaining k-means clustering and Fisher's Exact test
#'
#' @param selected_data     Returned list from the \code{\link{stim_cell_selector}} or
#'                          \code{\link{stim_cell_selector_single_marker}} function.
#' @param path              Path to the folder to save figures generated by this function.
#' @param verbose           Logical. To make function more verbose. Default is FALSE.
#'
#' @return This function generates figures in the specified path folder and returns 0.
#' @export
plot_sbp <- function(selected_data, path, verbose = FALSE){
  # Check if path exists; if not then create it.
  if(!is.null(path)){
    if(!dir.exists(path)){
      if(verbose){message(paste("Creating %s folder", path))}
      dir.create(path, recursive = TRUE)
    } else {
      if(verbose){message(paste(path, "folder already exists. Output will be over written."))}
    }
  }

  if("state_marker" %in% colnames(selected_data$selected_expr_data)){
    # Bind global variables.
    cluster <- k_cluster <- stim_status <- stim_type <- state_marker <- NULL

    # Group data according to clusters and stimulation type.
    group_data <- group_by(selected_data$stacked_bar_plot_data, cluster, stim_type, state_marker)

    # Split groups into a list of individual tables.
    split_groups <- group_split(group_data)

    # Create ggplot for a single group.
    for(i in 1:length(split_groups)){
      clust <- unique(split_groups[[i]]$cluster)
      stim <- unique(split_groups[[i]]$stim_type)
      state <- unique(split_groups[[i]]$state_marker)
      if(verbose){message(paste("Plotting for the cluster", clust, ", the stim type", stim, ", and the state", state))}
      stacked_plot <- ggplot(split_groups[[i]], aes(fill = k_cluster, y=count, x=stim_status)) +
        geom_bar(position="fill", stat="identity") +
        labs(title=paste("Cluster:", clust,
                         "; Stim type:", stim,
                         "; State marker:", state,
                         "\nFisher's p-value:", round(unique(split_groups[[i]]$f_p_val),3),
                         "; Stim cluster:",unique(split_groups[[i]]$stim_clust),
                         "; Fold change:", unique(split_groups[[i]]$fold_change) ,  sep=" "),
             x ="Stim Status", y = "Cell Count %", fill = "K-means Cluster")

      if(!is.null(path)){
        ggsave(paste0("plot_sbp_",clust,"_", stim, ".png"),
               plot = stacked_plot, device = "png", path = file.path(path), width = 6, height = 4, dpi = 300)
      }
    }
  } else {
    # Bind global variables.
    cluster <- k_cluster <- stim_status <- stim_type <- NULL

    # Group data according to clusters and stimulation type.
    group_data <- group_by(selected_data$stacked_bar_plot_data, cluster, stim_type)

    # Split groups into a list of individual tables.
    split_groups <- group_split(group_data)

    # Create ggplot for a single group.
    for(i in 1:length(split_groups)){
      clust <- unique(split_groups[[i]]$cluster)
      stim <- unique(split_groups[[i]]$stim_type)
      if(verbose){message(paste("Plotting for the cluster", clust, "and the stim type", stim))}
      stacked_plot <- ggplot(split_groups[[i]], aes(fill = k_cluster, y=count, x=stim_status)) +
        geom_bar(position="fill", stat="identity") +
        labs(title=paste("Cluster:", clust,
                         "; Stim type:", stim,
                         "\nFisher's p-value:", round(unique(split_groups[[i]]$f_p_val),3),
                         "; Stim cluster:",unique(split_groups[[i]]$stim_clust),
                         "; Fold change:", unique(split_groups[[i]]$fold_change) ,  sep=" "),
             x ="Stim Status", y = "Cell Count %", fill = "K-means Cluster")

      if(!is.null(path)){
        ggsave(paste0("plot_sbp_",clust,"_", stim, ".png"),
               plot = stacked_plot, device = "png", path = file.path(path), width = 6, height = 4, dpi = 300)
      }
    }
  }
  return(0)
}


#' Plot UMAPs for the Selected Cells
#'
#' @param selected_data      Returned list from the \code{\link{stim_cell_selector}} function.
#' @param path               Path to the folder to save figures generated by this function.
#' @param verbose            Logical. To make function more verbose. Default is FALSE.
#'
#' @return  This function generates figures in the specified path folder and returns 0.
#' @export
plot_umap <- function(selected_data, path, verbose = FALSE){

  # Check if the list contains data from UMAPSs.
  if(is.null(selected_data$umap_plot_data)){
    stop("No UMAP data in the list.")
  }

  # Check if path exists; if not then create it.
  if(!is.null(path)){
    if(!dir.exists(path)){
      if(verbose){message(paste("Creating %s folder", path))}
      dir.create(path, recursive = TRUE)
    } else {
      if(verbose){message(paste(path, "folder already exists. Output will be over written."))}
    }
  }

  # Bind global variables.
  UMAP1 <- UMAP2 <- cell_type <- cluster  <- stim_type <- NULL

  # Group data according to clusters and stimulation type.
  group_data <- group_by(selected_data$umap_plot_data, cluster, stim_type)

  # Split groups into a list of individual tables.
  split_groups <- group_split(group_data)

  # Create ggplot for a single group.
  for(i in 1:length(split_groups)){
    clust <- unique(split_groups[[i]]$cluster)
    stim <- unique(split_groups[[i]]$stim_type)
    if(verbose){message(paste("Plotting for the cluster", clust, "and the stim type", stim))}

    umap_plot <- ggplot(split_groups[[i]], aes(x = UMAP1, y = UMAP2, color = cell_type)) +
    geom_point(alpha = 0.25, size = 2) +
    labs(color = "Cell Type", title = paste0("Cluster: ", clust,
                                             "; Stim: ", stim,
                                             "\nTotal No. Cells: ", unique(split_groups[[i]]$tot_of_cells),
                                             "; No. of Cells Plotted: ", unique(split_groups[[i]]$no_of_cells))) +
    scale_x_continuous("UMAP1") +
    scale_y_continuous("UMAP2")

    if(!is.null(path)){
      ggsave(paste0("plot_umap_",clust,"_", stim, ".png"),
             plot = umap_plot, device = "png", path = file.path(path), width = 7, height = 5, dpi = 300)
    }
  }
  return(0)
}


#' Plot Individual Marker Distribution Before and After Selection
#'
#' @param original_data    Original tibble/data.frame what was used in \code{\link{stim_cell_selector}} function.
#' @param selected_data    List output of the \code{\link{stim_cell_selector}} function.
#' @param path             Path to the folder to save figures generated by this function.
#' @param verbose          Logical. To make function more verbose. Default is FALSE.
#'
#' @importFrom tidyr gather
#' @importFrom ggridges geom_density_ridges
#' @return Generates plots in the specified folder and returns 0 upon successfull completion.
#' @export
plot_kde <- function(original_data, selected_data, path, verbose = FALSE){
  # Check if path exists; if not then create it.
  if(!is.null(path)){
    if(!dir.exists(path)){
      if(verbose){message(paste("Creating %s folder", path))}
      dir.create(path, recursive = TRUE)
    } else {
      if(verbose){message(paste(path, "folder already exists. Output will be over written."))}
    }
  }

  if("state_marker" %in% colnames(selected_data$selected_expr_data)){
    # Bind global variables.
    distribution <- marker_exp <- NULL

    state_markers <- selected_data$state_markers
    cluster_col  <- selected_data$cluster_col

    # Convert the pre k-means data from wide to long form for the state markers.
    original_data <- original_data[, c(cluster_col, "stim_type", state_markers)]
    gather_ori_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
    for(state in state_markers){
      temp_df <- original_data[c(cluster_col, "stim_type")]
      marker_dat <- gather(as_tibble(original_data[state]), key = "state_marker", value = "marker_exp")
      temp_df <- cbind(temp_df, marker_dat, "distribution" = "stim")
      gather_ori_dat <- rbind(gather_ori_dat, temp_df)
    }
    gather_ori_dat <- rename(as_tibble(gather_ori_dat), "cluster" = cluster_col)

    # Convert the post k-means data from wide to long form for the state markers.
    selec_data <- selected_data$selected_expr_data
    selec_data <- selec_data[, c(cluster_col, "stim_type", "state_marker", "state_marker_exp")]
    gather_selec_dat <- cbind(selec_data, "distribution" = "selected")
    gather_selec_dat <- rename(as_tibble(gather_selec_dat), "cluster" = cluster_col)
    gather_selec_dat <- rename(as_tibble(gather_selec_dat), "marker_exp" = "state_marker_exp")

    summary <- selected_data$summary
    summary_grouped <- group_by(summary, cluster, stim_type) %>% group_split()

    for(i in 1:length(summary_grouped)){
      # Plot KDE of original (pre-k-means clustering) distribution overlaid
      # by the KDE of the k-selected distribution.
      cl <- as.character(unique(summary_grouped[[i]]$cluster))
      st <- as.character(unique(summary_grouped[[i]]$stim_type))
      states <- as.character(unique(summary_grouped[[i]]$state_marker))

      if(length(states) <= 4){
        n_col <- length(states)
        n_row <- 1
      } else if(length(states) > 4){
        n_col <- 4
        n_row_temp <- length(states) / n_col
        if(is.integer(n_row_temp)){
          n_row <- n_row_temp
        } else {
          n_row <- as.integer(n_row_temp) + 1
        }
      }

      clust_stim_k <- gather_selec_dat[gather_selec_dat$cluster == cl &
                                         gather_selec_dat$stim_type == st &
                                         gather_selec_dat$state_marker %in% states, ]

      clust_stim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl &
                                         gather_ori_dat$stim_type == st &
                                         gather_ori_dat$state_marker %in% states, ]

      clust_unstim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl &
                                           gather_ori_dat$stim_type == selected_data$unstim_label &
                                           gather_ori_dat$state_marker %in% states, ]
      clust_unstim_ori$distribution <- "unstim"

      clust_stim <- as_tibble(rbind(clust_stim_k, clust_stim_ori, clust_unstim_ori))

      p <- ggplot(data = clust_stim, aes(x = marker_exp , y = distribution)) +
        geom_density_ridges(aes(fill = distribution), scale = 1) +
        labs(x = "marker expression", title = paste0("Cluster: ", cl, "\nStim Type: ", st))

      base_size <- if(n_col >=4){20}else if(n_col < 4){10}
      kde_plot <- p + facet_wrap( ~ state_marker, nrow = n_row, ncol = n_col) +
        theme_set(theme_grey(base_size = base_size)) +
        theme(plot.title = element_text(face = "bold"))
        # theme(axis.text.x = element_text( size = 20 ),
        #       axis.text.y = element_text( size = 20 ),
        #       axis.title = element_text( size = 20 ),
        #       strip.text = element_text(size = 20),
        #       legend.text = element_text(size = 20),
        #       legend.title = element_text(size = 20),
        #       plot.title = element_text(size=22, face = "bold"))
      if(!is.null(path)){
        ggsave(paste0("plot_kde_", cl, "_", st, ".png"), plot = kde_plot, device = "png",
             path = path, width = n_col * 4, height = n_row * 3, dpi = 300)
      }
    }
  } else{

  # Bind global variables.
  distribution <- marker_exp <- NULL

  state_markers <- selected_data$state_markers
  cluster_col  <- selected_data$cluster_col

  # Convert the pre k-means data from wide to long form for the state markers.
  original_data <- original_data[, c(cluster_col, "stim_type", state_markers)]
  gather_ori_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
  for(state in state_markers){
    temp_df <- original_data[c(cluster_col, "stim_type")]
    marker_dat <- gather(as_tibble(original_data[state]), key = "state_marker", value = "marker_exp")
    temp_df <- cbind(temp_df, marker_dat, "distribution" = "stim")
    gather_ori_dat <- rbind(gather_ori_dat, temp_df)
  }
  gather_ori_dat <- rename(as_tibble(gather_ori_dat), "cluster" = cluster_col)

  # Convert the post k-means data from wide to long form for the state markers.
  selec_data <- selected_data$selected_expr_data
  selec_data <- selec_data[, c(cluster_col, "stim_type", state_markers)]
  gather_selec_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
  for(state in state_markers){
    temp_df <- selec_data[c(cluster_col, "stim_type")]
    marker_dat <- gather(as_tibble(selec_data[state]), key = "state_marker", value = "marker_exp")
    temp_df <- cbind(temp_df, marker_dat, "distribution" = "selected")
    gather_selec_dat <- rbind(gather_selec_dat, temp_df)
  }
  gather_selec_dat <- rename(as_tibble(gather_selec_dat), "cluster" = cluster_col)

  summary <- selected_data$summary
  if(length(state_markers) <= 4){
    n_col <- length(state_markers)
    n_row <- 1
  } else if(length(state_markers) > 4){
    n_col <- 4
    n_row_temp <- length(state_markers) / n_col
    if(is.integer(n_row_temp)){
      n_row <- n_row_temp
    } else {
      n_row <- as.integer(n_row_temp) + 1
    }
  }
  for(i in 1:nrow(summary)){
    # Plot KDE of original (pre-k-means clustering) distribution overlaid
    # by the KDE of the k-selected distribution.
    cl <- as.character(summary[[i,1]])
    st <- as.character(summary[[i,2]])

    clust_stim_k <- gather_selec_dat[gather_selec_dat$cluster == cl & gather_selec_dat$stim_type == st, ]
    clust_stim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl & gather_ori_dat$stim_type == st, ]
    clust_unstim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl & gather_ori_dat$stim_type == selected_data$unstim_label, ]
    clust_unstim_ori$distribution <- "unstim"
    clust_stim <- as_tibble(rbind(clust_stim_k, clust_stim_ori, clust_unstim_ori))

    p <- ggplot(data = clust_stim, aes(x = marker_exp , y = distribution)) +
      geom_density_ridges(aes(fill = distribution), scale = 1) +
      labs(x = "marker expression", title = paste0("Cluster: ", cl, "; Stim Type: ", st))

    base_size <- if(n_col >=4){20}else if(n_col < 4){10}
    kde_plot <- p + facet_wrap( ~ state_marker, nrow = n_row, ncol = n_col) +
      theme_set(theme_grey(base_size = base_size)) +
      theme(plot.title = element_text(face = "bold"))
    # theme(axis.text.x = element_text( size = 20 ),
      #       axis.text.y = element_text( size = 20 ),
      #       axis.title = element_text( size = 20 ),
      #       strip.text = element_text(size = 20),
      #       legend.text = element_text(size = 20),
      #       legend.title = element_text(size = 20),
      #       plot.title = element_text(size=22, face = "bold"))
    if(!is.null(path)){
      ggsave(paste0("plot_kde_", cl, "_", st, ".png"), plot = kde_plot, device = "png",
           path = path, width = n_col * 4, height = n_row * 3, dpi = 300)
    }
  }
}

  return(0)
}


#   # Convert the pre k-means data from wide to long form for the state markers.
#   original_data <- original_data[, c(cluster_col, "stim_type", state_markers)]
#   gather_ori_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
#   for(state in state_markers){
#     temp_df <- original_data[c(cluster_col, "stim_type")]
#     marker_dat <- gather(as_tibble(original_data[state]), key = "state_marker", value = "marker_exp")
#     temp_df <- cbind(temp_df, marker_dat, "distribution" = "original")
#     gather_ori_dat <- rbind(gather_ori_dat, temp_df)
#   }
#   gather_ori_dat <- rename(as_tibble(gather_ori_dat), "cluster" = cluster_col)
#
#   # Convert the post k-means data from wide to long form for the state markers.
#   selec_data <- selected_data$selected_expr_data
#   selec_data <- selec_data[, c(cluster_col, "stim_type", state_markers)]
#   gather_selec_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
#   for(state in state_markers){
#     temp_df <- selec_data[c(cluster_col, "stim_type")]
#     marker_dat <- gather(as_tibble(selec_data[state]), key = "state_marker", value = "marker_exp")
#     temp_df <- cbind(temp_df, marker_dat, "distribution" = "selected")
#     gather_selec_dat <- rbind(gather_selec_dat, temp_df)
#   }
#   gather_selec_dat <- rename(as_tibble(gather_selec_dat), "cluster" = cluster_col)
#
#   summary <- selected_data$summary
#   for(i in 1:nrow(summary)){
#     # Plot KDE of original (pre-k-means clustering) distribution overlaid
#     # by the KDE of the k-selected distribution.
#     cl <- as.character(summary[[i,1]])
#     st <- as.character(summary[[i,2]])
#     if(verbose){message(paste("Plotting for cluster", cl, "and stim type", st))}
#
#     clust_stim_k <- gather_selec_dat[gather_selec_dat$cluster == cl & gather_selec_dat$stim_type == st, ]
#     clust_stim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl & gather_ori_dat$stim_type == st, ]
#     clust_stim <- as_tibble(rbind(clust_stim_ori, clust_stim_k))
#     p <- ggplot(data = clust_stim, aes(x = marker_exp, fill = distribution)) + geom_density(size = 1, alpha = 0.25) +
#       labs(x = "marker expression", title = paste0("Cluster: ", cl, "; Stim Type: ", st))
#     kde_plot <- p + facet_wrap( ~ state_marker, nrow = 2, ncol = 5, scales = "free_y") +
#       theme( axis.text = element_text( size = 14 ),
#              axis.text.x = element_text( size = 20 ),
#              axis.text.y = element_text( size = 20 ),
#              axis.title = element_text( size = 20, face = "bold" ),
#              strip.text = element_text(size = 20),
#              plot.title = element_text(size=22, face = "bold"))
#
#     if(!is.null(path)){
#       ggsave(paste0("plot_kde_",cl, "_", st, ".png"), plot = kde_plot, device = "png",
#            path = file.path(path), width = 26, height = 18, dpi = 300)
#     }
#   }
#  return(0)
# }

