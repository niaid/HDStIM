---
title: "Stim Cell Selector"
author: "Rohit Farmer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stim Cell Selector}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The primary function `stim_cell_selector()` in `stimcellselector` package follows a heuristic approach to group cells into responding and non-responding. For a combination of cell population and stimulation type (e.g., CD127+ T-helper cells and interferon-alpha), `stim_cell_selector()` starts by performing k-means clustering on the combined set of cells from stimulated and unstimulated samples. K-means clustering is performed on expression data of all the state markers combined. Upon clustering using a contingency table as drawn below, a Fisher's exact test determines the effect size and the statistical significance of partitioning. Cells form the combinations that pass the Fisher's exact test are considered as responding. An optional UMAP plot can also be generated to verify the cell partitioning in responding and non-responding groups visually.

```{r con_table}
matrix(c(1500, 345, 230, 2500),nrow = 2, ncol = 2, 
       dimnames = list(c("Cluster1", "Cluster2"), c("Stim", "Unstim")))
```

An optional UMAP plot can also be generated to verify the cell partitioning in responding and non-responding groups visually.

## Example

An example using the sample CyTOF data set `chi11_1k` included in the package. 
`suppressMessages()` is used to reduce the verbosity of the `stim_cell_selector`
function.

```{r example}
library(stimcellselector)
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(ggplot2))

selected_data <-  stim_cell_selector(chi11_1k$expr_data, chi11_1k$state_markers,
                  chi11_1k$cluster_col, chi11_1k$stim_label,
                  chi11_1k$unstim_label, seed_val = 123, umap = TRUE, umap_cells = 500, verbose = FALSE)

class(selected_data)

attributes(selected_data)
```

### Output

`stim_cell_selector()` returns a list with the selected expression data, a summary, data to plot stacked 
bar plots to visualize the k-means and Fisher's exact test results and data to plot the optional UMAPs. 

```{r head_expr}
head(selected_data$selected_expr_data)
```

```{r head_summary}
head(selected_data$summary)
```
```{r head_stacked}
head(selected_data$stacked_bar_plot_data)
```
```{r head_umap}
head(selected_data$umap_plot_data)
```

### Figures

#### Plots Explaining k-means Clustering, Fisher's Exact Test, and Fold Change
Using the `stacked_bar_plot_data`, bar plots can be plotted that shows for a given
cluster and stimulation type the percentage of cells from the
stimulated and unstimulated samples that are clustered in the two k-means clusters.
`stacked_bar_plot_data` is returned for those combinations that pass the Fisher's
exact test after the k-means clustering. For each combination plot data also contains 
p-value for the Fisher's exact test and the fold change of the cells from the stimulated
samples that responded.

You can either use the function `plot_sbp` provided in the package to plot for all the
combinations of cluster and stimulation types in a specified folder like below

```r
plot_sbp(selected_data, path, verbose = FALSE)
```
or use the backend code below to plot only for the combinations of interest or with custom
aesthetics. The code below only plots the first combination.

```{r stacked_plot, fig.width = 7, fig.height = 5}
# Group data according to clusters and stimulation type.
group_data <- group_by(selected_data$stacked_bar_plot_data, cluster, stim_type)

# Split groups into a list of individual tables.
split_groups <- group_split(group_data)

# Create ggplot for a single group.
stacked_plot <- ggplot(split_groups[[1]], aes(fill = k_cluster, y=count, x=stim_status)) +
  geom_bar(position="fill", stat="identity") +
  labs(title=paste("Cluster:", unique(split_groups[[1]]$cluster), 
                   "; Stim type:", unique(split_groups[[1]]$stim_type), 
                   "\nFisher's p-value:", round(unique(split_groups[[1]]$f_p_val),3),
                   "; Stim cluster:",unique(split_groups[[1]]$stim_clust), 
                   "; Fold change:", unique(split_groups[[1]]$fold_change) ,  sep=" "),
       x ="Stim Status", y = "Cell Count %", fill = "K-means Cluster")

plot(stacked_plot)
```

#### UMAP Plots to Visually Inspect Responding and Non-Responding Cell Selection
Note: You can only generate these plot if you have asked UMAPs to be calcualted in 
the `stim_cell_selector()` function.

UMAP plots can be useful for visually inspecting how well selection method has 
separated responding and non-responding cells for a cluster and stimulation type
combination. The plots below shows all the cells from the unstimulated samples that fell in the
unstim cluster and responding and non-responding cells from the stimulated 
samples that fell in the stim and unstim clusters respectively. 

You can either use the function `plot_umap` provided in the package to plot for all the
combinations of cluster and stimulation types in a specified folder like below

```r
plot_umap(selected_data, path, verbose = FALSE)
```
or use the backend code below to plot only for the combinations of interest or with custom
aesthetics. The code below plots a UMAP for first combination using the output above.

```{r umap_plot, fig.width = 7, fig.height = 5}
# Group data according to clusters and stimulation type.
group_data <- group_by(selected_data$umap_plot_data, cluster, stim_type)

# Split groups into a list of individual tables.
split_groups <- group_split(group_data)

# Create ggplot for a single group.
umap_plot <- ggplot(split_groups[[1]], aes(x = UMAP1, y = UMAP2, color = cell_type)) +
geom_point(alpha = 0.25, size = 2) +
  labs(color = "Cell Type", title = paste0("Cluster: ", split_groups[[1]]$cluster, 
                                           "; Stim: ", split_groups[[1]]$stim_type,
                                            "\nTotal No. Cells: ", split_groups[[1]]$tot_of_cells,
                                            "; No. of Cells Plotted: ", split_groups[[1]]$no_of_cells)) +
  scale_x_continuous("UMAP1") +
  scale_y_continuous("UMAP2")
plot(umap_plot)
```

#### Distribution plots for Individual State Marker before and after Selection
You can either use the function `plot_kde` provided in the package to plot for all the
combinations of cluster and stimulation types in a specified folder like below

```r
plot_kde(original_data, selected_data, state_markers, cluster_col, path,
  verbose = FALSE)
```
or use the backend code below to plot only for the combinations of interest or with custom
aesthetics. The code below plots a distribution plot for the first combination using the output above.

```{r umap_kde, fig.width = 7, fig.height = 5}
library(tidyr)

# Convert the pre k-means data from wide to long form for the state markers.
original_data <- chi11_1k$expr_data
cluster_col <- chi11_1k$cluster_col
state_markers <- chi11_1k$state_markers
original_data <- original_data[, c(cluster_col, "stim_type", state_markers)]
gather_ori_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
for(state in state_markers){
  temp_df <- original_data[c(cluster_col, "stim_type")]
  marker_dat <- gather(as_tibble(original_data[state]), key = "state_marker", value = "marker_exp")
  temp_df <- cbind(temp_df, marker_dat, "distribution" = "original")
  gather_ori_dat <- rbind(gather_ori_dat, temp_df)
}
gather_ori_dat <- rename(as_tibble(gather_ori_dat), "cluster" = cluster_col)

# Convert the post k-means data from wide to long form for the state markers.
selec_data <- selected_data$selected_expr_data
selec_data <- selec_data[, c(cluster_col, "stim_type", state_markers)]
gather_selec_dat <- as_tibble(data.frame(matrix(nrow = 0, ncol = 5)))
for(state in state_markers){
  temp_df <- selec_data[c(cluster_col, "stim_type")]
  marker_dat <- gather(as_tibble(selec_data[state]), key = "state_marker", value = "marker_exp")
  temp_df <- cbind(temp_df, marker_dat, "distribution" = "selected")
  gather_selec_dat <- rbind(gather_selec_dat, temp_df)
}
gather_selec_dat <- rename(as_tibble(gather_selec_dat), "cluster" = cluster_col)

summary <- selected_data$summary
for(i in 1:nrow(summary)[1]){
  # Plot KDE of original (pre-k-means clustering) distribution overlaid
  # by the KDE of the k-selected distribution.
  cl <- as.character(summary[[i,1]])
  st <- as.character(summary[[i,2]])

  clust_stim_k <- gather_selec_dat[gather_selec_dat$cluster == cl & gather_selec_dat$stim_type == st, ]
  clust_stim_ori <- gather_ori_dat[gather_ori_dat$cluster == cl & gather_ori_dat$stim_type == st, ]
  clust_stim <- as_tibble(rbind(clust_stim_ori, clust_stim_k))
  p <- ggplot(data = clust_stim, aes(x = marker_exp, fill = distribution)) + geom_density(alpha = 0.25) +
    labs(x = "marker expression", title = paste0("Cluster: ", cl, "; Stim Type: ", st))
  kde_plot <- p + facet_wrap( ~ state_marker, nrow = 2, ncol = 5, scales = "free_y") +
    theme( axis.text = element_text( size = 14 ),
           axis.text.x = element_text( size = 14 ),
           axis.text.y = element_text( size = 14 ),
           axis.title = element_text( size = 14, face = "bold" ),
           plot.title = element_text(size=14, face = "bold"))
}
plot(kde_plot)
```
